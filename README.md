LRU cache

Небольшая и потокобезопасная реализация LRU (Least Recently Used) кэша на Go.

Особенности:

- Потокобезопасна для одновременных чтений/записей.
- Эвикшн (удаление) наименее используемых элементов при переполнении.
- Удобный API: Add, Get, Peek, Remove, Len, Clear.

Быстрый пример использования

```go
package main

import (
	"fmt"
	"lrucache"
)

func main() {
	cache := lrucache.NewLRU(2)
	cache.Add("a", 1)
	cache.Add("b", 2)

	if v, ok := cache.Get("a"); ok {
		fmt.Println("a =", v)
	}

	// добавление третьего элемента эвикнет наименее используемый
	cache.Add("c", 3)
}
```

API заметки

- NewLRU(capacity int) \*LRU — создаёт кэш. Если capacity <= 0, используется 1.
- Add(key string, value any) — добавляет/обновляет значение и помечает как недавно использованное.
- Get(key string) (any, bool) — возвращает значение и флаг найденности; при успешном получении элемент помечается как MRU.
- Peek(key string) (any, bool) — возвращает значение без изменения порядка использования.
- Remove(key string) bool — удаляет ключ, возвращает true если элемент был удалён.
- Len() int — число элементов в кэше.
- Clear() — очищает кэш.

Тесты

В репозитории есть набор базовых unit-тестов. Для запуска тестов выполните:

```bash
cd /path/to/LRUcache
go test ./...
```

Рекомендации

- При необходимости логировать или обрабатывать эвикнутые элементы можно расширить реализацию, добавив onEvict hook.
- Для проверки отсутствия гонок запускайте `go test -race`.

Лицензия и вклад
Проект небольшой — используйте и улучшайте как нужно. Если хотите, могу добавить бенчмарки, onEvict-хук или generic-версию с типизацией.
